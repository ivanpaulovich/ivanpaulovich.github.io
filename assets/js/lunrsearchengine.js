
var documents = [{
    "id": 0,
    "url": "/404.html",
    "title": "404",
    "body": "404 Page does not exist!Please use the search bar at the top or visit our homepage! "
    }, {
    "id": 1,
    "url": "/about-ivan-paulovich",
    "title": "About Ivan Paulovich",
    "body": "Agile Software Developer, Tech Lead, 20+ GitHub projects about Clean Architecture, SOLID, DDD and TDD. Speaker/Streamer Projects: I have been supporting open source projects for many years focused on Clean Architecture, Domain-Driven Design, Test-Driven Development and SOLID principles. Clean Architecture MangaStarWatchForkClean Architecture sample with . NET Core. Use cases as central organising structure, decoupled from frameworks and technology details dotnet new cajuStarWatchForkThis dotnet-new template for . NET Back-ends increases productivity on building applications with the Hexagonal, Clean or Event Sourcing architectures styles. This tool generates a . NET back-end with built-in best practices in 15 seconds! Clean Architecture WebApi EF CoreStarWatchForkThe simplest Clean Architecture demo on how to implement a Web Api using . NET Core and Entity Framework todoStarWatchForkCommad-Line Task management with storage on your GitHub Event Sourcing JamboStarWatchForkAn Hexagonal Architecture with DDD + Aggregates + Event Sourcing using . NET Core, Kafka e MongoDB (Blog Engine) Hexagonal Architecture AcerolaStarWatchForkAn Hexagonal Architecture service template with DDD, CQRS, TDD and SOLID using . NET Core 2. 0. All small features are testable and could be mocked. Adapters could be mocked or exchanged. Questions or bug reports?: Let me know at ivan@paulovich. net! Follow @ivanpaulovichFollow @ivanpaulovichIvan Paulovich"
    }, {
    "id": 2,
    "url": "/categories",
    "title": "Categories",
    "body": ""
    }, {
    "id": 3,
    "url": "/",
    "title": "Home",
    "body": "      Featured:                                                                                                                                                                                                           Shinning Frameworks and DDD?                              :               I talked today about the Shinning Frameworks Trap. Don’t fall into it!:                                                                                                                                                                       Ivan Paulovich                                12 Sep 2019                                                                                                                                                                                                                                                                                                                  Clean Architecture: The User Interface is a detail                              :               Today I talk about Presenters. I hope you enjoy and I looking forward feedback. :                                                                                                                                                                       Ivan Paulovich                                11 Sep 2019                                                                                                                                                                                                                                                                                                                        TDD and Hexagonal Architecture Video                              :               Quick tips for the ones following the Hexagonal Architecture, please apply TDD outside-in and and do not start implementing Mocks for every dependency. :                                                                                                                                                                       Ivan Paulovich                                07 Sep 2019                                                                                                                                                                                                                                                                                                                                                                                                Clean Architecture Essentials                              :               The “Software Architecture”:                                                                                                                                                                       Ivan Paulovich                                20 Jan 2018                                                                                                                      All Stories:                                                                                                     Shinning Frameworks and DDD?              :       I talked today about the Shinning Frameworks Trap. Don’t fall into it!:                                                                               Ivan Paulovich                12 Sep 2019                                                                                                                                     Clean Architecture: The User Interface is a detail              :       Today I talk about Presenters. I hope you enjoy and I looking forward feedback. :                                                                               Ivan Paulovich                11 Sep 2019                                                                                                                                     Designing and Testing Video              :       I started a new series of videos introducing Clean Architecture, Open Source and . NET Development. :                                                                               Ivan Paulovich                10 Sep 2019                                                                                                                                     TDD and Hexagonal Architecture Video              :       Quick tips for the ones following the Hexagonal Architecture, please apply TDD outside-in and and do not start implementing Mocks for every dependency. :                                                                               Ivan Paulovich                07 Sep 2019                                                                                                                                     Designing and Testing Input Validation in . NET Core: The Clean Architecture way              :       Almost every software requires some input validation implementation. Due to the importance there are frameworks and guidelines to help us complete the task, should not be difficult to write good. . . :                                                                               Ivan Paulovich                07 Sep 2019                                                                                                                                     Clean Architecture Essentials - Part I              :       I have been following the Clean Architecture principles on the todo development and I would like to share my experience with you. The strategies and decisions I have made could. . . :                                                                               Ivan Paulovich                20 Apr 2019                                               &laquo; Prev       1        2        3      Next &raquo; "
    }, {
    "id": 4,
    "url": "/robots.txt",
    "title": "",
    "body": "      Sitemap: {{ “sitemap. xml”   absolute_url }}   "
    }, {
    "id": 5,
    "url": "/page2/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 6,
    "url": "/page3/",
    "title": "Home",
    "body": "{% if page. url == “/” %}       Featured:       {% for post in site. posts %}    {% if post. featured == true %}      {% include featuredbox. html %}    {% endif %}  {% endfor %}  {% endif %}       All Stories:         {% for post in paginator. posts %}    {% include postbox. html %}    {% endfor %}    {% include pagination. html %}"
    }, {
    "id": 7,
    "url": "/shinning-frameworks-trap/",
    "title": "Shinning Frameworks and DDD?",
    "body": "2019/09/12 - I talked today about the Shinning Frameworks Trap. Don’t fall into it! "
    }, {
    "id": 8,
    "url": "/the-ui-is-a-detail/",
    "title": "Clean Architecture: The User Interface is a detail",
    "body": "2019/09/11 - Today I talk about Presenters. I hope you enjoy and I looking forward feedback.  "
    }, {
    "id": 9,
    "url": "/designing-testing-video/",
    "title": "Designing and Testing Video",
    "body": "2019/09/10 - I started a new series of videos introducing Clean Architecture, Open Source and . NET Development. Leave your comments, questions and they may be featured on the next video.  "
    }, {
    "id": 10,
    "url": "/tdd-hexagonal-architecture-video/",
    "title": "TDD and Hexagonal Architecture Video",
    "body": "2019/09/07 - Quick tips for the ones following the Hexagonal Architecture, please apply TDD outside-in and and do not start implementing Mocks for every dependency.  Before implementing a Mock you should implement the standard Fake.  "
    }, {
    "id": 11,
    "url": "/designing-testing-input-validation-in-dotnet-core-the-clean-architecture-way/",
    "title": "Designing and Testing Input Validation in .NET Core: The Clean Architecture way",
    "body": "2019/09/07 - Almost every software requires some input validation implementation. Due to the importance there are frameworks and guidelines to help us complete the task, should not be difficult to write good validation code right? Wrong! Validation is the most common source of issues in Web applications. Let me explain the code smells:  Untestable Validation Code: To test the validation logic it is required to write tests against the whole universe of combinations, it is not practical.  Mixed Validation Code: Every method is concerned about input validation. Complexity increases on every new feature added.  Business Logic dependent on Frameworks: Too much business code wrote using frameworks. What if we need to change the framework?Have you seen bad code like this? 1234567891011121314151617181920212223242526public void RegisterCustomer(    string ssn,    string name,    double initialAmount){  if (string. IsNullOrWhiteSpace(ssn))    throw new SSNShouldNotBeEmptyException( The 'ssn' field is required );  Regex regex = new Regex(RegExForValidation);  Match match = regex. Match(ssn);  if (!match. Success)    throw new InvalidSSNException( Invalid SSN format. Use YYMMDDNNNN.  );  if (string. IsNullOrWhiteSpace(name))    throw new NameShouldNotBeEmptyException( The 'name' field is required );  if (value &lt; 0)      throw new AmountShouldBePositiveException( The 'Amount' should be positive.  );  //  // other logic implementation omitted  //}Read the next topics to learn how to cure this anaemia or navigate to Guidelines to Enrich Anemic Domain Models with TDD/DDD for more examples. What I suggest you to do?: I suggest that we take leverage of frameworks and still write testable code. I would describe the steps as following:  Validate the required fields and types in isolation.  Validate the fields values format (e-mail, phone number, personnummer).  Validate if the combination of fields are valid. Suppose that a system manages the Customer’s Wallet Account. The first use case is Register a Customer, let’s see how would be the validation steps: 1. Validating fields in isolation with Data Annotations: The Web layer is responsible for many things, we do not want to flood the Web with business logic. Let’s keep the framework dependencies under control. So I would add only the [Required] attribute here. The benefit is that these attributes are automatically read by the ASP. NET framework for built in validation. The other benefit is that Swagger extensions use this information to generate the API description, it is too many benefits to avoid Data Annotations. The rule is:  Keep it simple. 1234567891011121314151617181920public sealed class RegisterRequest{  /// &lt;summary&gt;  /// SSN  /// &lt;/summary&gt;  [Required]  public string SSN { get; set; }  /// &lt;summary&gt;  /// Name  /// &lt;/summary&gt;  [Required]  public string Name { get; set; }  /// &lt;summary&gt;  /// Initial Amount  /// &lt;/summary&gt;  [Required]  public double InitialAmount { get; set; }}The immediate benefit is that Validation is built in ASP. NET Core, completely integrated with Swagger (Open API Specification).  2. Validating fields format in the Domain Layer: Fields data format validation is a business concern. For that reason I want them to be implemented in the Domain layer. My suggestion is that you add a folder for Value Objects with classes like this: In Sweden the Social Security Number is called Personnummer and the format is YYMMDDNNNN.  As instance of SSN only exists if it is valid.  It is immutable (without methods changing the _text property.  It is serializable.  It is unique by its internal property values. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public sealed class SSN : IEquatable&lt;SSN&gt;{  private string _text;  const string RegExForValidation = @ ^\d{6,8}[-|(\s)]{0,1}\d{4}$ ;  private SSN() { }  public SSN(string text)  {    if (string. IsNullOrWhiteSpace(text))      throw new SSNShouldNotBeEmptyException( The 'SSN' field is required );    Regex regex = new Regex(RegExForValidation);    Match match = regex. Match(text);    if (!match. Success)      throw new InvalidSSNException( Invalid SSN format. Use YYMMDDNNNN.  );    _text = text;  }  public override string ToString()  {    return _text;  }  public bool Equals(SSN other)  {    return this. _text == other. _text;  }  public override bool Equals(object obj)  {    if (ReferenceEquals(null, obj))    {      return false;    }    if (ReferenceEquals(this, obj))    {      return true;    }    if (obj is string)    {      return obj. ToString() == _text;    }    return ((SSN) obj). _text == _text;  }  public override int GetHashCode()  {    unchecked    {      int hash = 17;      hash = hash * 23 + _text. GetHashCode();      return hash;    }  }}The name just need to be a string. We could change it to be more restrictive. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public sealed class Name : IEquatable&lt;Name&gt;{  private string _text;  private Name() { }  public Name(string text)  {    if (string. IsNullOrWhiteSpace(text))      throw new NameShouldNotBeEmptyException( The 'Name' field is required );    _text = text;  }  public override string ToString()  {    return _text;  }  public override bool Equals(object obj)  {    if (ReferenceEquals(null, obj))    {      return false;    }    if (ReferenceEquals(this, obj))    {      return true;    }    if (obj is string)    {      return obj. ToString() == _text;    }    return ((Name) obj). _text == _text;  }  public override int GetHashCode()  {    unchecked    {      int hash = 17;      hash = hash * 23 + _text. GetHashCode();      return hash;    }  }  public bool Equals(Name other)  {    return this. _text == other. _text;  }}The amount should be positive. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public sealed class PositiveAmount : IEquatable&lt;PositiveAmount&gt;{  private readonly Amount _value;  private PositiveAmount() { }  public PositiveAmount(double value)  {    if (value &lt; 0)      throw new AmountShouldBePositiveException( The 'Amount' should be positive.  );    _value = new Amount(value);  }  public override bool Equals(object obj)  {    if (ReferenceEquals(null, obj))    {      return false;    }    if (ReferenceEquals(this, obj))    {      return true;    }    if (obj is double)    {      return (double) obj == _value. ToDouble();    }    return ((PositiveAmount) obj). _value == _value;  }  public Amount ToAmount()  {    return _value;  }  internal PositiveAmount Add(PositiveAmount positiveAmount)  {    return _value. Add(positiveAmount. _value);  }  public override int GetHashCode()  {    unchecked    {      int hash = 17;      hash = hash * 23 + _value. GetHashCode();      return hash;    }  }  internal Amount Subtract(PositiveAmount positiveAmount)  {    return _value. Subtract(positiveAmount. _value);  }  public bool Equals(PositiveAmount other)  {    return this. _value == other. _value;  }}3. Validating fields format in the Domain Layer: The use cases accept Input messages and are made of Value Objects. 12345678910111213141516171819202122232425262728public sealed class RegisterInput{  public SSN SSN { get; }  public Name Name { get; }  public PositiveAmount InitialAmount { get; }  public RegisterInput(SSN ssn, Name name, PositiveAmount initialAmount)  {    if (ssn == null)    {      throw new InputValidationException($ {nameof(ssn)} cannot be null.  );    }    if (name == null)    {      throw new InputValidationException($ {nameof(name)} cannot be null.  );    }    if (initialAmount == null)    {      throw new InputValidationException($ {nameof(initialAmount)} cannot be null.  );    }    SSN = ssn;    Name = name;    InitialAmount = initialAmount;  }}How I use it?: In the Web Layer the controller has an action that requires a RegisterRequest object, the action is responsible for creating the RegisterInput object then calling the use case.  The interesting about Request/Response objects is that they are made of serializable objects (eg. int, double and string).  The Request/Response are responsible for carrying the data from and back to the User.  Of course you can’t trust it, you need to create Input objects. 123456789101112131415161718192021222324/// &lt;summary&gt;/// Register a customer/// &lt;/summary&gt;/// &lt;response code= 200 &gt;The registered customer was create successfully. &lt;/response&gt;/// &lt;response code= 400 &gt;Bad request. &lt;/response&gt;/// &lt;response code= 500 &gt;Error. &lt;/response&gt;/// &lt;param name= request &gt;The request to register a customer&lt;/param&gt;/// &lt;returns&gt;The newly registered customer&lt;/returns&gt;[HttpPost][ProducesResponseType(StatusCodes. Status200OK, Type = typeof(RegisterResponse))][ProducesResponseType(StatusCodes. Status400BadRequest)][ProducesResponseType(StatusCodes. Status500InternalServerError)][SwaggerRequestExample(typeof(RegisterRequest), typeof(GetCustomerDetailsRequestExample))]public async Task&lt;IActionResult&gt; Post([FromBody][Required] RegisterRequest request){  var input = new RegisterInput(    new SSN(request. SSN),    new Name(request. Name),    new PositiveAmount(request. InitialAmount));  await _registerUseCase. Execute(input);  return _presenter. ViewModel;}The beautiful of this approach is that the use cases can use Input objects and read the Value Objects which are always valid. 1234567891011121314151617181920212223242526272829303132public sealed class Register : IUseCase{  // code ommited for simplication  public async Task Execute(RegisterInput input)  {    if (input == null)    {      _outputHandler. Error( Input is null.  );      return;    }    var customer = _entityFactory. NewCustomer(input. SSN, input. Name);    var account = _entityFactory. NewAccount(customer);    ICredit credit = account. Deposit(_entityFactory, input. InitialAmount);    if (credit == null)    {      _outputHandler. Error( An error happened when depositing the amount.  );      return;    }    customer. Register(account);    await _customerRepository. Add(customer);    await _accountRepository. Add(account, credit);    await _unitOfWork. Save();    RegisterOutput output = new RegisterOutput(customer, account);    _outputHandler. Standard(output);  }}Value Objects are powerful, you can use them everywhere in the Application/Domain layers and you know there are valid. Throwing and Catching Exceptions: You saw previously that the validation logic is throwing exceptions, so we need to catch them somewhere. I suggest you to add a filter on the Web layer and all Domain Exceptions are returned as BadRequest objects. 12345678910111213141516171819public sealed class BusinessExceptionFilter : IExceptionFilter{  public void OnException(ExceptionContext context)  {    DomainException domainException = context. Exception as DomainException;    if (domainException != null)    {      var problemDetails = new ProblemDetails      {          Status = 400,          Title =  Bad Request ,          Detail = domainException. Message      };      context. Result = new BadRequestObjectResult(problemDetails);      context. Exception = null;    }  }}Testing: You can test from different perspectives. I would prioritize testing the Input objects from Unit Tests. 12345678910111213141516171819202122232425262728293031323334353637383940414243444546[Fact]public void GivenNullSSN_InputNotCreated_ThrowsInputValidationException(){  var actualEx = Assert. Throws&lt;InputValidationException&gt;(    () =&gt; new RegisterInput(      null,      new Name( Ivan ),      new PositiveAmount(10)    ));  Assert. Contains( ssn , actualEx. Message);}[Fact]public void GivenNullName_InputNotCreated_ThrowsInputValidationException(){  var actualEx = Assert. Throws&lt;InputValidationException&gt;(    () =&gt; new RegisterInput(      new SSN( 19860817999 ),      null,      new PositiveAmount(10)    ));  Assert. Contains( name , actualEx. Message);}[Fact]public void GivenNullPositiveAmount_InputNotCreated_ThrowsInputValidationException(){  var actualEx = Assert. Throws&lt;InputValidationException&gt;(    () =&gt; new RegisterInput(      new SSN( 19860817999 ),      new Name( Ivan ),      null    ));  Assert. Contains( initialAmount , actualEx. Message);}[Fact]public void GivenValidData_InputCreated(){  var actual = new RegisterInput(    new SSN( 19860817999 ),    new Name( Ivan ),    new PositiveAmount(10)  );  Assert. NotNull(actual);}My Thoughts on Fluent Validation: I see FluentValidation perfect fit for objects validation that I have not control on design. Suppose that I need to consume a old WCF service and the message has constraints on it. I would implement a custom FluentValidator on the infrastructure layer. I would not use it for Value Objects amd Input Messages validation. Conclusion: Use the frameworks with cautions, implement the business validation inside the Domain and clean up fat methods replacing primitive objects with proper Value Objects. Want to see it in action? The demo is running on Heroku: Happy Codding! Do you agree/disagree? "
    }, {
    "id": 12,
    "url": "/clean-architecture-essentials-part-1/",
    "title": "Clean Architecture Essentials - Part I",
    "body": "2019/04/20 - I have been following the Clean Architecture principles on the todo development and I would like to share my experience with you. The strategies and decisions I have made could help you in future projects. Use Cases: The first step I did was to pick a simple domain, I chose the “Tasks Management” domain and the expected use cases are listed below:  Add a new task.  List all tasks.  Rename task title.  Mark task to done.  Mark task to incomplete.  Remove task. To summarize the Clean Architecture style I would say that it is an application designed around use cases with the implementation guided by tests. So the next step in the todo tool development was to setup the test project. I created the TodoList. UnitTests for tests and TodoList. Core for the use cases implementation. That is right, when I started the development I did not create an “Web API project” instead I consider that the first application consumer are the unit tests. Tests: Going further. The tests and production code are created at the same time. For instance when designing the TodoUseCase, I created a test case that verifies null input. This simple test guides me into discovering the classes that I need. 123456[Fact]public void GivenNullInput_ThrowsException(){  var sut = new TodoUseCase();  . . . }The next thing I did was to create the TodoUseCase class definition: 1234567public sealed class TodoUseCase{  public void Execute(Request request)  {    throw new NotImplementedException();  }}Then I continue with the test design: 123456[Fact]public void GivenNullInput_ThrowsException(){  var sut = new TodoUseCase();  Assert. Throws&lt;Exception&gt;(() =&gt; sut. Execute(null));}Later I go back to the production code: 12345678910public sealed class TodoUseCase{  public void Execute(Request request)  {    if (request == null)      throw new Exception( Request is null );    . . .   }}This is the beginning of Clean Architecture series. What do you think? "
    }, {
    "id": 13,
    "url": "/todo-clean-architecture-implementation/",
    "title": "todo: My new Clean Architecture implementation",
    "body": "2019/04/19 - I released a dotnet tool to manage tasks via the comnand line. The tasks are stored in a secret gist in your own GitHub account. Checkout a few commands: If you have your machine up to date with the latest . NET Core SDK and you are interest to see todo in action please run: 1$ dotnet tool install -g todoAfter that you need to grant access gist permissions to the todo tool. In case you are running in a OSX checkout the issue with zsh: command not found: todo. Ask me about it! "
    }, {
    "id": 14,
    "url": "/clean-architecture-implementation-sample-dotnet/",
    "title": "Clean Architecture Implementation Sample With .NET",
    "body": "2019/03/10 - Hi all, I started a new open source project about Clean Architecture with . NET and I invite you all to check out! The use cases are about a Todo List App and I am using the principles from the book to design the solution. "
    }, {
    "id": 15,
    "url": "/clean-architecture-tdd-baby-steps/",
    "title": "Clean Architecture and TDD",
    "body": "2019/02/19 - Nowadays all software development companies are self-titled Agile (if you are not Agile you are not cool right?). Most companies are following the SCRUM ceremonies, they adopted small developers teams, they have a SM and PO roles.  Are SCRUM ceremonies enough to be Agile? How the software implementation interfer? I could say a lot about a company on how they answer the following question:  Are teams delivering working software to real users on every iteration (including the first) and gathering feedback? If the answer is No I suppose the following:  Teams usually do not deliver on the first iteration because they are designing an architecture or adding framework dependencies.  They do not gather user feedback on every iteration.  Long lead time for every new feature, the business value is retained for long time. Agile is about collaboration with people, gathering feedback from real users!  Why software take so long to reach the production environment? Why they have so many bugs? The software architecture is the main reason for features taking long time to be released to production. It is common that teams do a lot of effort designing a big archictecture up front that requires fancy frameworks for every feature. The end result is an application overwhelmed of dependencies, error prone and hard to change. The application reachs production with many bugs because the team spend most of the time configuring the web server, working with ORM frameworks and the user interfaces. The team did not have time in collaboration with the users trying to understand the use cases and implementing the business rules. By a lack of confidence, the developers try to implement the frameworks on the initial sprints to avoid getting caught unprepared on the later sprints. This decision create coupling with technology. Let me ask some questions: - Do we need a database server to implement the business rules? Do we need a running web server to gather the real user feedback?  We don’t need a SQL Server or a running Web Server to gather user feedback on the business rules. To design a tightly coupled architecture we just need to begin with configuring the database, the web server, the frameworks then in the remaining time implementing the business rules.  With so many moving parts we fail to get the real user feedback! Worse… it will fail slowly. Now… suppose that we wish to design a software architecture that prioritize collaboration with Domain Experts. We desire an application loose coupled to a database and the web server, we want to decide about these details when we have enough information. Is implementing the business requirements the priority for your organization? If that’s the case you will need to work on your programming disciplines. Just Enough Architecture: What if we could focus on business requirements and ignore everything else? The idea behind “Ports and Adapters” is to decouple the high level modules from the low level modules, in simple terms you could decouple the business rules from the database and user interface.  As you can see on the left side there are driving actors:  Test Harness User InterfaceThe secondary actors are on the right side:  Mocked Database SQL Database Adapter Mocked Web server Web server AdapterThe use cases are implemented inside the Application Layer. What I am saying is that whatever the right or left side dependencies are you always can delay their implementation by prioritizing tests and mocks. The use cases are the important thing you need to focus on! Is there a correct order to implement an Hexagonal Architecture? Ports and Adapters Implementation Workflow: The benefit of “Ports and Adapters” is that the application use cases could be implemented in isolation from external services, so we can delay the database and web server implementation by creating fake implementations.  What about the driving actors? When should I implement them? The first driving adapter you should implement are the Test Harness. And to run tests you don’t need an user inteface, see how you don’t need to worry about button colors and font faces? These tests will guide the use case implementation against a mocked database.  With the knowledge acquired by the unit tests implementation you can more confident design the User Interface then get user feedback. Every stage is a learning process, be open to change the use cases implementation and test harness at anytime! You now can go deeper in details and implement how the application consume the database, and you can run your existing tests against this secondary actor. Should I say that you will do small changes in the application use cases to support this new adapter? You will! The last step you run the User Interface against a real database implementation and get more feedback! Optional Acceptance Tests: We could create tests for the User Interface. Considering that you followed the previous steps. Why TDD is Agile?: Agile methodology is not about doing things quickly without quality. When designing tests you may feel that you are wasting time and in reality is the opposite:  The only way to go fast is to go well. Every time you yeild to the temptation to trade quality for speed, you slow down. Every time. Uncle Bob. Software should be implemented incrementally and on every sprint you should acquire business knowledge that help you be effective on the next sprint. "
    }, {
    "id": 16,
    "url": "/hexagonal-and-clean-architecture-styles-with-net-core-reviewed/",
    "title": "Hexagonal and Clean Architecture Styles with .NET Core (Reviewed)",
    "body": "2018/08/16 - Unfortunately remain very common that applications are built on top of frameworks and databases. I see that developers usually implement software that mimics the data tables instead of design software driven by the business domain. As time goes by, the software becomes highly coupled to these external details and what happens next is the application evolution been dictated by the vendors support. Hexagonal Architecture (aka Ports and Adapters) is one strategy to decouple the use cases from the external details. It was coined by Alistar Cockburn more than 13 years ago, and this received improvements with the Onion and Clean Architectures. Let me introduce the Hexagonal Architecture’s intent:  Allow an application to equally be driven by users, programs or tests, and to be developed and tested in isolation from any of its eventual run-time devices and databases. I need to point out that Business Rules and Use Cases should be implemented inside the Application Layer and they need to be maintained for the project’s life, in the other hand everything that give support for external capabilities are just external details, they can be replaced for different reasons, and we do not want the business rules to be coupled to them. It is important to distinguish between the business and the details. Business Rules and Use Cases: The business rules are the fine grained rules, they encapsulate entity fields and constraints. Also the business rules are the use cases that interacts with multiple entities and services. They together creates a process in the application, they should be sustained for a long time. If the difference remain not clear, this Uncle Bob quote will clarify:  Business Rules would make or save the business money, irrespective of whether they were implemented on a computer. They would make or save money even if they were executed manually. In the DDD age, we have patterns to describe the business rules with Entities, Value Objects, Aggregates, Domain Services and so on. They are a perfect match with Hexagonal Architecture. External Details: In most scenarios we can defer the implementation of external details and still keep the development progress. If your answer is yes for any of the next questions, you are probably dealing with peripheral details:  Does the application needs an database to persist state? Does the application requires an User Interface? Does the application consumes an external API?These are common external details which can be mocked, faked or their concrete implementation be replaced for different reasons. I suggest you to defer their implementation while you discover more of the domain. Keep in mind the Uncle Bob’s quote:  A good architecture allows major decisions to be deferred and a good architect maximize the number of decisions not made. Visual Studio makes it easy to add libraries for Reflection, Serialization, Security and many others Nuget packages in our projects.   The problem begin when we add these libraries to our Application and Domain. These libraries are just details and should be left out of the Application Layer. What we should do?  Stop going for shinning frameworks.  Stop writing classes with inheritance from frameworks.  Focus on the business rules, make them clear on your Application and Domain Layers.  Don’t fall into tooling traps like scaffolding.  Create the appropriate abstraction for these peripheral concerns. Moving on, there are design principles that you should understand before implementing the Hexagonal Architecture style. Dependency Inversion Principle (DIP): In the next example, the DIP was applied when decoupling our Use Cases from the Repositories. It is important to understand this priciple as it was applied to decouple other stuff in our source code. Let’s remember the DIP then navigate through one example:    High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. Let’s see how I applied this principle in the next example: On the left side we found in red an Layered Application where the DepositUseCase depends on the AccountSQLRepository implementation. It is a coupled way to write code. On the right side in blue, by adding an IAccountRepository and applying DIP then the AccountSQLRepository has its dependency pointing inwards.  The DepositUseCase is the High-level module that do not depend on database details, instead it depends on IAccountRepository abstraction.  The IAccountRepository is the abstraction that do not depend on database details.  The AccountSQLRepository is the low-level module that depends on IAccountRepository abstraction. The following listing of DepositUseCase with DIP: That is the main idea behind Hexagonal Architecture, whenever our application requires an external service we use the Port (a simple interface) and we implement the Adapter behind the abstraction. Separation of Concerns (SoC): Our application requires some external capabilities but the application is not concerned about their implementation details, only their abstractions are visible to the application layer. We apply SoC by creating boundaries around the Adapters and by allowing them to be developed and tested in isolation. It’s a good practice to have different packages for each Adapter implementation. We could have an specific Adapter for an SQL Database and an specific Adapter for Azure Storage both could be replaced with little effort. That is the idea behind the Hexagonal Architecture, keep the options open as long as possible and the ability to rollback if necessary. We can quote Uncle Bob’s Plugin Architecture, about the relationship between Visual Studio and Resharper. Not a single line of VS knows about Resharper, but Resharper is developed based on the Visual Studio abstractions. They are developed by different companies one in Seattle and another in Moscow and still running well together. Hexagonal Architecture Style Characteristics: With this style we have:  An independent Business Domain to embody the fine grained business rules.  Use Cases interacting with the Domain and independent of external services.  Interfaces providing ports.  Adapters providing implementations of frameworks, data access and UI.  Externally the user, other systems and services. One way to explain the Hexagonal Architecture is by its shapes. Take a look at the following picture:  The blue potato shape at the center is the Domain Layer and there are reasons for it. Every business domain has its own rules, very specific business rules, that is the reason of its undefined shape. For example, I designed our Domain Layer with DDD Building Blocks.  The application has an hexagonal shape because each of its sides has specifics protocols.  The Ports and Adapters are implemented outside of the application as plugins.  Externally we have other systems.  The Hexagonal is splitted in left and right. On the left we implement the driving actors and on the right we implement the secondary actors. The direction of the dependencies goes inwards the center, so the Domain Layer does not know the Application Layer but the Application Layer depends on the Domain, the same rule applies to the outer layers. Layers: Let’s describe the Dependency Diagram below:  The Domain Layer is totally independent of other layers and frameworks.  The Application Layer depends exclusively on the Domain Layer.  The Application Layer is independent of frameworks, databases and UI.  The UI Layer and the Infrastructure Layer provides implementations for the Application needs.  The UI Layer depends on Application Layer and it loads the Infrastructure Layer by indirection. We should pay attention that the Infrastructure Layer can have many concerns. I recommend to design the infrastructure in a way you can split it when necessary, particularly when you have distinct adapters with overlapping concerns. It is important to highlight the dashed arrow from the UI Layer to the Infrastructure layer. That is the where Dependency Injection is implemented, the concretions are loaded closer to the Main function. And there is a single setting in a external file that decides all the dependencies to be loaded. Application Layer: Let’s dig into the Application Business Rules implemented by the Use Cases in our Bounded Context. As said by Uncle Bob in his book Clean Architecture:  Just as the plans for a house or a library scream about the use cases of those buildings, so should the architecture of a software application scream about the use cases of the application. Use Cases implementations are first-class modules in the root of this layer. The shape of a Use Case is an Interactor object that receives an Input, do some work then pass the Output through the caller. That’s the reason I am an advocate of feature folders describing the use cases and inside them the necessary classes: At your first look of the solution folders, you can build an idea of the purpose of this software. It seems like it can manage your Banck Account, for example you can Deposit or Withdraw money. Following we see the communication between the layers: The Application exposes an interface (Port) to the UI Layer and another interface (another Port) to the Infrastructure Layer.  What have you seen until here is Enterprise + Application Business Rules enforced without frameworks dependencies or without database coupling. Every details has abstractions protecting the Business Rules to be coupled to tech stuff. Adapters for the User Interface: Now we advance to the next layer, at the User Interface Layer we translate the input in a way that the Use Cases can understand, it is good practice to do not reuse entities in this layer because it could create coupling, the front-end has specific frameworks, other ways of creating its data structures, different presentation for each field and validation rules. In our implementation we have the following feature folders for every use case:  Request: a data structure for the user input (accountId and amount).  A Controller with an Action: this component receives the DepositRequest, calls the appropriate Deposit Use Case which do some processing then pass the output through the Presenter instance.  Presenter: it converters the Output to the Model.  Model: this is the return data structure for MVC applications. We must highlight that the Controller knows the Deposit Use Case and it is not interested about the Output, instead the Controller delegates the responsibility of generating a Model to the Presenter instance. An Presenter class is detailed bellow and it shows a conversion from the DepositOutput to two different ViewModels. One ViewModel for null Outputs and another ViewModel for successful deposits. Adapters for the Infrastructure: Another external layer is the Infrastructure Layer that implements Data Access, Dependency Injection Framework (DI) and other frameworks specifics. In this example we have multiple data access implementations.  How and When the DI is configured: We group the DI by Modules, so we have an module for the Entity Framework Data Access that requires a connection string like this: There is others modules in the same code base and we can run using them by changing the autofac. entityframework. json, an convenient way to setup desired modules. The autofac. json in set on the very beginning in the Program. cs. As it should be! Source Code: You can download the source code on Clean Architecture github repository or through the following commands: Conclusion: With Hexagonal Architecture you design a decoupled software that allows major decisions to be deferred, all business rules will be isolated from peripheral concerns. And you have the option to try different adapters with less effort. Have your experience when the code base gets coupled to an specific framework? What are your experience with Hexagonal Architecture? Leave your comment. "
    }, {
    "id": 17,
    "url": "/rich-domain-model-with-ddd-tdd-reviewed/",
    "title": "Rich Domain Model with DDD/TDD (Reviewed)",
    "body": "2018/07/29 - Through my journey of building Domain Models I had good and bad experiences that today I share with you to save a few hours of your development time. These are opinionated approaches that I follow when building Rich Domain Models. A Rich Domain Model is the technical part when applying DDD, it envolves the building blocks like Entity, Value Objects and Aggregate Root. The goal is to build a ubiquitous language between developers and stakeholders using the a vocabulary that describes the business rules. What are the business rules? Its what’s make or save money, irrespective of whether they were implemented on a computer or manually. This kind of rules are simple to be described in words as they do not require a database, in fact the database is just an IO device that our software requires to persist state. We could say the same about the Web, it is only a delivery mechanism to present information to our users and has nothing to do with the business rules. Having that clear is my way of thinking but what I find in our industry is a spaghetti of business rules, persistence libraries and frameworks code. In the next few topics I’m going to expose code issues we want to avoid before you decide to invest time building rich domains models . The code issues I am referring to are known as code smells, and they are associated with architecture and development problems. Code Smells to Avoid: The opposite of the Rich Domain Models are the Anemic Domain Models, in this second one the business logic are implemented far from the classes that own the data, it brings low cohesion and nonexistent encapsulation. The next topics introduce common code smells related to Anemic Domain Models. Feature Envy: It’s the situation where a client class access the fields of another class more than it’s own data. In order to keep the policies of the second class consistent the consumer needs to validate and manipulate multiple fields together. This code smell is easy to find when “Application Services” or “Extension Methods” are envy of other Entities fields. These application services implement the policies that should be managed by the Entities classes. Just like this: The solution for this code smell is to move the envy method into the class that owns the data then hide the internal details.  Primitive Obsession: It’s the use of primitive types like string, integer or arrays to ensure the fine grained business rules. As there is no encapsulation, the code get repeatedly validated in different places. These issues are found:  When “Security Social Numbers”, “Phone numbers” or Money are repeatedly validated from the UI through the database.  When a client class needs to manipulate arrays of other classes in order to keep the data and policies consistent. At first having methods to manipulate arrays everywhere (eg. linq) seems an advantage. Then the different places do not implement in the same way, or you need a big effort to maintain it consistent.  The generic arrays and collections leaks abstraction, they provide access to language specific methods instead of the methods known by the ubiquitous language. To fix this issue we need to create a value object that encapsulate the fine grained business logic and for collections we should use the adapter pattern with the proper methods to manipulate the items. Public Setters Abuse: This is far the most common code smell seen in . NET applications, I guess is due to the Entity Framework popularity and its code samples and patterns that exposes every entity properties. To clarify the problem I share the fundamentals of object-oriented programming language, its encapsulation.  When composing objects into a new type, we want the new type to exhibit simpler behavior than all of it’s component parts considered together.  Steve Freeman (GOOS) Let’s suppose that a entity have three properties and they are all public exposed. So there is no encapsulation, the complete complexity of the class are the equals as all internal fields. It allows the consumers to change the internal fields at any time anywhere. The consumers need to understand how to change the properties and to maintain the state consistent. This code issue are seen together with business classes been designed to meet the ORM frameworks restrictions. The end result are classes that only reflect the tables structure. To fix this issue we need to remove the public setters and move the logic to and create new methods. Anemic Classes: It’s the photograph of a poor implemented business requirements. This kind of classes only store data, they do not implement behaviors or policies. How to fix that? Not simple answer but you need to start thinking on:  If you are calling two setters in a row, you are missing a concept (Oliver Gierke) These code smells alone doesn’t mean that the code is bad at all. In certain conditions these characteristics are necessary. The problem happens when multiple code smells are combined in a single code base, then the software gets harder to change, the regression tests are required for small changes and the bugs are frequent. Let’s build a new mindset, the journey is worth it! How to Enrich Domain Models?: I begin following TDD practices, it gives me confidence to enrich the model in different places incrementally. I know two TDD approaches, the inside-out and the outside-in. And to be honest I prefer the inside-out approach, with the guidance of DDD building blocks. The DDD building blocks guides me in the correct path. I start thinking on Entities, Value Objects and Aggregates then I move outside to the Use Cases and Repositories. I am able to discover a lot of domain, design the model without working on database and UI. Next, a short description of what we gonna need from DDD.  Value Objects: its immutable custom types that are distinguishable only by the state of its properties.  Entities: its custom types that are distinguishable by an identity property, it has data and behaviors.  Aggregate roots: a kind on entity that maintain the object graph in consistent state and is associated to a repository.  Use Cases: coordinates the operations with the domain objects and services.  Repositories and Services: provides access to external resources. We are going to learn by example, next you see some business rules then the implementation. To design a Rich Model we need to concern only on business policies, all the external details like databases, HTTP and serialization will be addressed later. In our example, we define the business with the following use cases and requirements:  The customer can register a new account.  Allow to deposit into an existing account.  Allow to withdraw from an existing account.  Accounts can be closed only if they have zero balance.  Accounts does not allow to withdraw more than the current account balance.  Allow to get the account details.  Allow to get the customer details.  It’s required from the customer to fill Name, SSN and to deposit an initial amount when registering. We could identify the following DDD patterns for these business:  Aggregate Roots: Customer and Account.  Entities: Credit and Debit.  Value Objects: Name, SSN and Amount.  Use Cases: Register, Deposit, Withdraw, Close, Get Customer Details, Get Account Details. We warn you that our model are persistent ignorant, it privileges the business and we avoid ORM frameworks interference in our classes. To design the Customer we think first on the test specification. CustomerTests. cs: We point out that the Customer and Account are aggregate roots and they only know each other by their IDs. The Customer. Register(. . ) method does not accept the Account instance, instead accepts only the AccountId. Customer. cs: All fields are private set so all the state changes are made by the methods, the specific Accounts property return an IReadOnlyCollection to prevent unexpected changes from consumers. In this class the state consistent from the constructor that requires the customer details to the Register(. . ) method. Previously, I said that I would not corrupt the Model in order to persist the entities state. I made and exception for the factory method that receives the complete Customer fields then it creates a Customer instance. To persist the objects graph the repository can read the public properties. Account. cs: I added the sealed modifier to the Account class to prevent inheritance. I am an advocate of composition over inheritance, and I added this modifier to the domain classes to be clear with my intention. I don’t want to allow consumers to create unnecessary coupling. The transaction history can be modified only in the next situations:  By the deposit method which adds and transaction.  By the withdraw method which adds and transaction.  By the factory method which recreates the list. The consistency is ensured by not allowing the client to make changes on the TransactionCollection property. SSN. cs: This class is a value object for the Swedish Personnummer and it encapsulates the complexity of validating the string format. Whenever I refer to a string personnummer I can use this class. Source Code: There are more examples of Rich Domain in my GitHub repository. You can find the Aggregates, Entities and the Values objects. Also everything is covered by Unit Tests. The source code is available on GitHub DDD/TDD Rich Domain. 123git clone https://github. com/ivanpaulovich/ddd-tdd-rich-domain. gitcd ddd-tdd-rich-domain. /build. shGive it a stargazer, fork it if you like. Conclusion: Building rich domains is not an easy task, in fact it requires much more effort to implement the business requirements and how to hide the internal details. Fortunately we can leverage on TDD practices to validate the API usage, and to ensure it’s correctness. The DDD patterns help us understand how the components should work together. We highlight that the principles of high cohesion and low coupling are required to lower the complexity of the code base. Have you implemented a Rich Domain Model? How was your experience? Leave your feedback. "
    }, {
    "id": 18,
    "url": "/hexagonal-architectural-in-2-minutes/",
    "title": "Hexagonal Architectural in 2 minutes",
    "body": "2018/07/18 - Hi folks, I testing my content on youtube, I plan to share short ideas straight to the point. The first video is about Hexagonal Architecture and its a 2 minutes talk. If you liked this new format, leave your feedback!  "
    }, {
    "id": 19,
    "url": "/guidelines-to-enrich-anemic-domain-models-tdd-ddd/",
    "title": "Guidelines to Enrich Anemic Domain Models with TDD/DDD",
    "body": "2018/06/24 - In my previous blog posts you could see Clean Architecture and Hexagonal implementations.  Continuing this series I am going deeper on the Domain Layer, through my journey of building rich domain models I had bad and good experiences that now I would like to share with you. These are my opinionated approaches that could streamline your learning process. What are the business rules? The business rules would make or save the business money, irrespective of whether they were implemented on a computer or manually. This kind of rules are simple to be described in words as they do not require a database, in fact the database are just an IO device that our software requires to persist state. We could say the same about the Web, the way we present the information to our users has nothing to do with the business rules. That is the mine mindset but what I find in our industry is a mix of business, persistence and frameworks.  Photo by li tzuni on Unsplash[/caption] To begin we need to understand the code issues we want to avoid before decide to invest time and effort on building rich domains models. The code issues I am referring to are known as code smells, and they are associated with architecture and development problems. Code Smells to Avoid: The opposite of the Rich Domain Models are the Anemic Domain Models, in this second one the business logic are implemented far from the classes that own the data, it brings low cohesion and nonexistent encapsulation. The next topics introduce common code smells in Anemic Domain Models. Feature Envy: It’s the situation where a client class access the fields of another class more than it’s own data. In order to keep the policies of the second class consistent the consumer needs to validate and manipulate multiple fields together. This code smell is easy to find:  When “Application Services” or “Extension Methods” are envy of the Entities fields. These kind of classes implement the policies that should be managed by the data owner, in most of cases the Entities classes. Primitive Obsession: It’s the use of primitive types (string, int, float, arrays) for simple tasks that ensures the business rules. There common issues are seen:  When you see “Security Social Numbers”, “Phone numbers” and Money been repeatedly validated from the UI through the database. To fix this issue we need to create a custom type to encapsulate this logic.  When a client class needs to manipulate arrays in external classes in order to keep the data and policies consistent. Generic Lists and Collections leaks abstraction, they provide access to built-in methods to manage the items that are not desired by the business rules. To fix this issue we need to create an Adapter class with the proper methods to manipulate the items. Abuse of the Public Setters:  When composing objects into a new type, we want the new type to exhibit simpler behavior than all of it’s component parts considered together.  Steve Freeman (GOOS) The classes that exposes all the internal complexity by allowing the consumers to change the internal fields at any time and anywhere. Due to the non-existent encapsulation the consumers need to understand how to change the class properties and to keep the state consistent. To fix this issue we need to remove the public setters and move the logic to proper methods. Business Classes Designed for ORM: Instead of design the classes to meet business requirements the classes are designed to meet the ORM frameworks requirements. The end result are classes that only reflect tables structure. Anemic Classes: It’s the photograph of a poor implemented business requirements. This kind of classes only store data, they do not implement behaviors or policies. These code smells alone doesn’t mean that the code is bad at all. In certain conditions these characteristics are necessary. The problem happens when multiple code smells are combined in a single code base, then the software gets harder to change, the regression tests are required for small changes and the bugs are frequent. Check out the Refactoring Guru for a compiled list of code smells. Let’s build a new mindset, the journey is worth it! How to Enrich Domain Models?: The reason we invest effort on enrich the Domain is to prove it’s viability, we can do a lot of work without worrying about the database or presentations concerns.  To design a rich model we need to concern only on business policies, all the external details like Databases, HTTP and serialization will be addressed later. In our example, we define the business with the following use cases and requirements:  The customer can register a new account.  Allow to deposit into an existing account.  Allow to withdraw from an existing account.  Accounts can be closed only if they have zero balance.  Accounts does not allow to withdraw more than the current account balance.  Allow to get the account details.  Allow to get the customer details.  It’s required from the customer to fill Name, SSN and to deposit an initial amount when registering. We are going straight to the entities and use cases and see what we can do with OO principles to design a Rich Domain Model. We could identify the following patterns:  Aggregate Roots: Customer and Account Entities: Credit and Debit Value Objects: Name, SSN and Amount Use Cases: Register, Deposit, Withdraw, Close, Get Customer Details, Get Account Details. We alert that our model are persistent ignorant, it privileges the business and we avoid ORM frameworks interference in our classes. To design the Customer we think first on the test specification. We would like the Customer API to be used this way: CustomerTests. cs: We point out that the Customer and Account are aggregate roots and they must know each other by their IDs. The Customer. Register(. . ) method does not accept the Account instance, instead accepts only the AccountId. Customer. cs: All fields are private sets so all the state changes are made by the methods, the specific Accounts property return an IReadOnlyCollection to prevent unexpected changes from consumers. In this class the state consistency are ensured from the constructor that requires the customer details to the Register(. . ) method. Previously, I said that I would not corrupt the Model in order to persist the state. I made and exception for the factory method that receives the complete Customer fields as parameters and it creates a Customer instance. To persist the objects the repository can use the public properties to get the Customer state. Account. cs: I added the sealed modifier to the Account class to prevent inheritance. I am an advocate of composition over inheritance, and I added this modifier to the domain classes to be transparent with my intention. I don’t want the consumers creating unnecessary coupling. The transaction history can be changed only in the next situations:  By the deposit method which adds and transaction.  By the withdraw method which adds and transaction.  By the factory method which recreates the list. The consistency is ensured by not allowing the client to make changes on the TransactionCollection property. SSN. cs: This class is a value object for the Swedish Personnummer and it encapsulates the complexity of validating the string format. Whenever I am refer to a string personnummer I can use this class. Source Code: There are more examples of Rich Domain in my GitHub repository. You can find the Aggregates, Entities and the Values objects. Also everything is covered by Unit Tests. You can download the source code on DDD/TDD Rich Domain. 123git clone https://github. com/ivanpaulovich/ddd-tdd-rich-domain. gitcd ddd-tdd-rich-domain. /build. sh﻿ Conclusion: Building rich domains is not an easy task, in fact it requires much more to think on implementing the business requirements and how to hide the internal details. Fortunately we can leverage on TDD practices to validate the API usage, and to ensure it’s correctness. The DDD patterns help us understand how the components should work together. We highlight that the principles of high cohesion and low coupling are required to lower the complexity of the code base. What do you think? "
    }, {
    "id": 20,
    "url": "/hexagonal-architecture-dot-net/",
    "title": "Hexagonal Architecture with .NET",
    "body": "2018/05/26 - The feedback of the Clean Architecture for . NET Applications made me feel like I needed to take a step back and introduce some concepts first, so I will present my implementation of Hexagonal Architecture to make easier to understand them completely. Unfortunately in my previous experiences in different companies, remain very common that applications are built on top of frameworks and databases. I see that many developers are used to implement software that mimics the data tables instead of design software driven by the business domain. As time goes by, the software becomes highly coupled to these external details and what happens next is the application evolution been dictated by what the vendors support. Hexagonal Architecture (aka Ports and Adapters) is one strategy to decouple the use cases from the external details. It was coined by Alistar Cockburn more than 13 years ago, and it is getting better with the Onion and Clean Architectures. Let me introduce the Hexagonal Architecture’s intent:  Allow an application to equally be driven by users, programs or tests, and to be developed and tested in isolation from any of its eventual run-time devices and databases. I need to point out that everything that gives support for external capabilities are just External Details, on the other side everything that contains the Business Rules and Use Cases should be inside the A_pplication Layer_ and they need to be sustained for long time.  In our software we have to distinguish between one and the other. External Details: In most scenarios we can defer the implementation of external details and still validate the application behavior. If your answer is yes for any of the next questions, you are probably dealing with peripheral details:  Does the application needs an database to persist state? Does the application requires an User Interface? Does the application consumes an external API?These are common external details which can be mocked, faked or their concrete implementation be replaced for different reasons. I suggest to defer their implementation while you discover more of the domain. Keep in mind the Uncle Bob’s quote:  A good architecture allows major decisions to be deferred and a good architect maximize the number of decisions not made. Visual Studio makes easier to add libraries for Reflection, Serialization, Security and many others Nuget packages in our projects.   The problem begin when we add these libraries to our Application and Domain. These libraries are just details and should be out of the Application. What we can do?  Stop writing classes with inheritance from frameworks.  Stop going for shinning objects.  Focus on the business rules, make them clear on your Application and Domain Layers.  Don’t fall into tooling traps.  Create the appropriate abstraction for these peripheral concerns. For didactic reasons we call these details as Ports and Adapters in Hexagonal Architecture style. Business Rules and Use Cases: The business rules are the fine grained rules, they encapsulate entity fields and conditions. Also the business rules are the use cases that interacts with many entities and services. They together give create process in the application, they should be sustained for a long time. If it’s still unclear, this Uncle Bob phrase might help:  Business Rules would make or save the business money, irrespective of whether they were implemented on a computer. They would make or save money even if they were executed manually. In the DDD age, we have patterns to describe business with Entities, Value Types, Aggregates, Domain Services and so on. They are a perfect match with Hexagonal Architecture. Moving on, there are design principles that must be clear before implementing Hexagonal Architecture style. Dependency Inversion Principle (DIP): In the next example, the DIP was applied when decoupling our Application Services from the Repositories. And this principle was used to decouple many other things in our Application. Let’s remember the DIP and navigate through one example:    High-level modules should not depend on low-level modules. Both should depend on abstractions. Abstractions should not depend on details. Details should depend on abstractions. For the following example checkout the concepts:  The DepositService is the High-level module that do not depend on database details, instead it depends on IAccountRepository abstraction.  The IAccountRepository is the abstraction that do not depend on database details.  The AccountSQLRepository is the low-level module that depends on IAccountRepository abstraction. To clarify the idea I created the next picture with the before and after applying DIP:  On the left side of the next picture we find in blue an Layered Application where the DepositService depends on AccountSQLRepository.  And on the right side in green, by adding an IAccountRepository and applying DIP then the AccountSQLRepository has your dependency pointing inwards. aaaaaThe following listing of DepositService shows an implementation. Suggestion: clone the Acerola repository for the full implementation. 123456789101112131415161718192021222324252627282930313233343536public class DepositService : IDepositService{ private readonly IAccountReadOnlyRepository accountReadOnlyRepository; private readonly IAccountWriteOnlyRepository accountWriteOnlyRepository; private readonly IResultConverter resultConverter; public DepositService(  IAccountReadOnlyRepository accountReadOnlyRepository,  IAccountWriteOnlyRepository accountWriteOnlyRepository,  IResultConverter resultConverter) {  this. accountReadOnlyRepository = accountReadOnlyRepository;  this. accountWriteOnlyRepository = accountWriteOnlyRepository;  this. resultConverter = resultConverter; } public async Task&lt;DepositResult&gt; Process(DepositCommand command) {  Account account = await accountReadOnlyRepository. Get(command. AccountId);  if (account == null)   throw new AccountNotFoundException(   $ The account {command. AccountId} does not exists or is already closed.  );  Credit credit = new Credit(account. Id, command. Amount);  account. Deposit(credit);  await accountWriteOnlyRepository. Update(account, credit);  TransactionResult transactionResult = resultConverter. Map(credit);  DepositResult result = new DepositResult(   transactionResult,   account. GetCurrentBalance(). Value);  return result; }}That is the main idea behind Hexagonal Architecture, every time our application requires an external service we implement adapter behind an abstraction. Separation of Concerns (SoC): Our application requires some external capabilities but the application is not concerned about their implementation details, only their abstractions are visible to the application layer. We apply SoC by creating boundaries around the Adapters and by allowing them to be developed and tested in isolation. Usually, we have different packages for each Adapter. We could have an specific Adapter for an SQL Database and an specific Adapter for Azure Storage which could be replaced with little effort. That is the idea behind the Hexagonal Architecture, keep the options open as long as possible and the ability to rollback if necessary. We can quote Uncle Bob’s Plugin Architecture, with the relationship between Visual Studio and Resharper. Not a single line of VS knows about Resharper, but Resharper is developed based on the Visual Studio abstractions. They are developed by different companies one in Seattle and another in Moscow and still running well together. Hexagonal Architecture Style Characteristics: With this style we have:  An independent Business Domain to embody the small set of critical business rules.  Application Services to implement the use cases.  Ports to get the input.  Adapters providing implementations of frameworks and access to databases.  Externally the user, other systems and services. One way to explain the Hexagonal Architecture is by its shapes. Take a look at the following picture:  The blue potato shape at the center is the Domain and there are reasons for it. Every business domain has its own rules, different specifications from each other, that is the reason of its undefined shape. For instance, I designed our Domain Layer with DDD Patterns.  The application has an hexagonal shape because each of its sides has specifics protocols, in our example we have Commands and Queries giving access to the Application.  The Ports and Adapters are implemented outside of the application as plugins.  Externally we have other systems. The direction of the dependencies goes inwards the center, so the Domain Layer does not know the Application Layer but the Application Layer depends on the Domain, the same rule applies to the outer layers. Layers: Let’s describe the Dependency Layer Diagram below:  The domain is totally independent of other layers and frameworks.  The application depends on Domain and is independent of frameworks, databases and UI.  Adapters provides implementations for the Application needs.  The UI depends on Application and loads the Infrastructure by indirection. We should pay attention that the Infrastructure Layer can have many concerns. I recommend to design the infrastructure in a way you can split it when necessary, particularly when you have distinct adapters with overlapping concerns. It is important to highlight the dashed arrow from the UI Layer to the Infrastructure layer. That is the where Dependency Injection is implemented, the concretions are loaded closer to the Main function. And there is a single setting in a external file that decides all the dependencies to be loaded. The Application Layer: To make simpler the Application Layer implementation, I split it in two stacks: one for the transactions and other for the queries.  When the user sends an Deposit Input, it goes to the transactions stack, it is converted into a Command that goes through the DepositService, uses the Entities to enforce the business rules and the transaction is finally persisted in a database by an adapter.  The other stack is tinnier and implemented by the Adapters. It is used only for querying view objects. With this approach we avoid the degradation of our domain because we don’t need to represent every Query Results into Entities. Use Cases Components: It is very important to organize the Application Layer with the use case vocabulary. I recommend one folder for each use case, as we have in the following example:  Command (DepositCommand. cs) Use case Interface (IDepositService. cs) Use case Implementation (DepositService. cs) Command Result (DepositResult. cs)With this approach we have an application design that supports new use case implementations with fewer changes in existing code base. This keep the work effort for new use cases implementations constants along the sprints in an Agile methodology. Queries: For the Query side, in the Application Layer we have only an small interface. And in the Infrastructure Layer we have the Adapter implementation. 1234public interface IAccountsQueries{ Task&lt;AccountResult&gt; GetAccount(Guid id);}By having an guarantee that the query side does not make changes in state. We can take advantage of better solutions for reading. For instance we can use caching, segregated databases to boost performance and it could be done inside the Adapter. Ports: A Port is an way an Actor can interact with the Application Layer. The role of the Port is to translate the Actor’s input into structures the Application Services can understand. For instance a Port could be an Web Form, an Console App or another system. For this article the Port supports the REST protocol and was implemented using WebApi framework. 1234567891011121314151617181920212223242526272829303132333435363738[Route( api/[controller] )]public class AccountsController : Controller{ private readonly IDepositService depositService; public AccountsController(  IDepositService depositService) {  this. depositService = depositService; } /// &lt;summary&gt; /// Deposit from an account /// &lt;/summary&gt; [HttpPatch( Deposit )] public async Task&lt;IActionResult&gt; Deposit(\[FromBody\]DepositRequest request) {  var command = new DepositCommand(   request. AccountId,   request. Amount);  DepositResult depositResult = await depositService. Process(command);  if (depositResult == null)  {   return new NoContentResult();  }  Model model = new Model(   depositResult. Transaction. Amount,   depositResult. Transaction. Description,   depositResult. Transaction. TransactionDate,   depositResult. UpdatedBalance  );  return new ObjectResult(model); }}The WebApi has Controllers that do not depends on Application Services implementation, its easy to mock this services. Port Components: We segregate Port Components by use cases, for the Deposit use case:  Request (DepositRequest. cs) Controller + Action (DepositController. cs) Model (Model. cs)Source Code: You can download the source code on Acerola GitHub repository or through the following commands: 12345dotnet new -i Paulovich. Caju::0. 5. 0dotnet new hexagonal \ --data-access entityframework \ --use-cases full \ --user-interface webapiConclusion: With Hexagonal Architecture you design a decoupled software that allows major decisions to be made in the future, all business rules will be isolated from peripheral concerns. And you have the option to try different ports and adapters with less effort. What comes next? Leave your comment. "
    }, {
    "id": 21,
    "url": "/check-out-these-awesome-hexagonal-and-clean-architectures-implementations/",
    "title": "Architecture Templates for dotnet new",
    "body": "2018/05/22 - I am releasing an new version of my Architecture Templates for dotnet new. We are working on testing, compatibility and documentation. Paulovich. Caju 0. 4. 0 Release notes:  New architecture tips for each layer in Clean Architecture template. Check out the blog post.  Command line breaking changes. See the topic below. How to install the latest version: To install the latest version use: 1dotnet new -i Paulovich. CajuThen run dotnet new and check the templates list:       Templates   Short Name   Language   Tags         Hexagonal Architecture for . NET Applications!   hexagonal   [C#]   Common/Library/Web API       Event-Sourcing for . NET Applications!   eventsourcing   [C#]   Common/Library/Web API       Clean Architecture for . NET Applications!   clean   [C#]   Common/Library/Web API   Command Line Changes: I changed the short name caju to three more specifics commands hexagonal, eventsourcingand clean. The old commands were: 123dotnet new caju --architecture-style hexagonaldotnet new caju --architecture-style eventsourcingdotnet new caju --architecture-style cleanThe new commands in Paulovich. Caju 0. 4. 0 package are: 123dotnet new hexagonaldotnet new eventsourcingdotnet new cleanMuch more clear now! Remember that each template has slight differences, so add the –help for details. This templates segregation are required to speed up the updates. "
    }, {
    "id": 22,
    "url": "/clean-architecture-for-net-applications/",
    "title": "Clean Architecture for .NET Applications",
    "body": "2018/05/15 - I’d like to introduce my service template for . NET Applications based on the Clean Architecture style. You can download the full source code or you can play with the dotnet new caju tool using the following commands: 12345$ dotnet new -i Paulovich. Caju::0. 4. 0$ dotnet new clean \ --data-access mongo \ --use-cases full \ --user-interface webapiAs the SOLID principles and the Clean Architecture rules are worth to write about it, I am starting this blogging series explaining the decisions we have made through the development of the Manga Project. Feedback are welcome! Clean Architecture expects at least 4 layers and in each layer there are common components. Starting with the layers from inside to the outer ones:  Enterprise Business Rules Application Business Rules Interface Adapters Frameworks &amp; DriversLet’s talk about on how we implemented this layers in the Manga Project! 1. Enterprise Business Rules: Beginning with the Enterprise Business Rules Layer we are talking about Aggregates, Entities, Value Objects and others patterns of a rich Domain. In our specific Bounded Context we have the Customer and the Account as Aggregate Roots, also the Credit/Debit transactions as Entities and last but no least we have the Name, Person Number and Amount as Value Objects.  In short words, the previous components are the business entities that encapsulates fields and prevents unexpected changes or behaviors, these components maintain the application state in the most reliable way. Now, let me highlight some characteristics of this data structures:  Aggregate Roots controls the entities graph and are used by repositories for data persistence. The software craftsman Vaugn Vernon wrote the rules for designing effective aggregates and I highly recommend watching the video Curing you Domain Model Anemia with Effective &amp; Clean Tips from the Real World from Edson Yanaga these helped me a lot to enrich my model.  You will see that majority of the classes have properties with private sets or protected sets in order to prevent unexpected state changes from the several clients along the Use Cases (we avoid public sets when possible).  We had to make exceptions for constructors due of deserialization requirements.  Value Objects are expected to be immutable and they have the most closed fields. Fields that change only when we create a new instance of the Value Object. You can find interesting Domain Entities in our GitHub, following there are an Aggregate Root example: 12345678910111213141516171819202122232425public class Customer : Entity, IAggregateRoot{  public virtual Name Name { get; protected set; }  public virtual PIN PIN { get; protected set; }  public virtual int Version { get; protected set; }  public virtual AccountCollection Accounts { get; protected set; }  protected Customer()  {    Accounts = new AccountCollection();  }  public Customer(PIN pin, Name name)    : this()  {    PIN = pin;    Name = name;  }  public virtual void Register(Guid accountId)  {    Accounts = new AccountCollection();    Accounts. Add(accountId);  }}2. Application Business Rules: Let’s move to the Application Business Rules Layer that contains the Use Cases of our Bounded Context. As said by Uncle Bob in his book Clean Architecture:  Just as the plans for a house or a library scream about the use cases of those buildings, so should the architecture of a software application scream about the use cases of the application. So our Use Cases implementations are first-class modules in the root of this layer. The shape of a Use Case is an Interactor object that receives an Input, do some work then pass the Output through the currently Presenter instance as shown in the following figure: In the previous Flow of Control we have:  An Action in the CustomersController calls a method in the RegisterInteractor with the RegisterInput data; The RegisterInteractor that implements **IInputBoundary** calls the **CustomerRepository** passing the **CustomerAggregate** object created in that Use Case.  Then the RegisterInteractor generates a RegisterOutput data object (POCO) and passes it to the currently IOutputBoundary.  The RegisterPresenter which implements IOutputBoundary receives the RegisterOutput and creates the RegisterModel.  The RegisterModel created in step 4 are returned by the Action. In our example application we have other Use Cases that allow Customer Registration and Bank Account transactions. In simple terms these are the Use Cases:  Customer Registration.  Get Customer Account Details.  Get Account Details.  Deposit to an account.  Withdraw from an account.  Close an account. Continuing to explore our implementation you will see that the RegisterInteractor receives the services by DI. The Process method does the Application Business Rules, calls the Repository and at the end passes the RegisterOutput through the RegisterPresenter instance. Let’s take a look at the RegisterInteractor class: 123456789101112131415161718192021222324252627282930313233343536373839public class RegisterInteractor : IInputBoundary{  private readonly ICustomerWriteOnlyRepository customerWriteOnlyRepository;  private readonly IAccountWriteOnlyRepository accountWriteOnlyRepository;  private readonly IOutputBoundary outputBoundary;  private readonly IOutputConverter outputConverter;    public RegisterInteractor(    ICustomerWriteOnlyRepository customerWriteOnlyRepository,    IAccountWriteOnlyRepository accountWriteOnlyRepository,    IOutputBoundary outputBoundary,    IOutputConverter outputConverter)  {    this. customerWriteOnlyRepository = customerWriteOnlyRepository;    this. accountWriteOnlyRepository = accountWriteOnlyRepository;    this. outputBoundary = outputBoundary;    this. outputConverter = outputConverter;  }  public async Task Process(RegisterInput input)  {    Customer customer = new Customer(input. PIN, input. Name);    Account account = new Account(customer. Id);    Credit credit = new Credit(account. Id, input. InitialAmount);    account. Deposit(credit);    customer. Register(account. Id);    await customerWriteOnlyRepository. Add(customer);    await accountWriteOnlyRepository. Add(account, credit);    CustomerOutput customerOutput = outputConverter. Map(customer);    AccountOutput accountOutput = outputConverter. Map(account);    RegisterOutput output = new RegisterOutput(customerOutput, accountOutput);    outputBoundary. Populate(output);  }}What have you seen until here is Enterprise + Application Business Rules enforced without frameworks dependencies or without database coupling. Every details have abstractions protecting the Business Domain to be coupled to tech stuff. 3. Interface Adapters: Now we advance to the next layer, at the Interface Adapters Layer we translate the User input in a way that the Interactors understands, it is good practice to do not reuse entities in this layer because it creates coupling, the front-end has frameworks, other ways of creating his data structures, different presentation for each field and validation rules. In our implementation we have the following components for every use case:  Request: a data structure for the user input.  A Controller with an Action: this component receives the user input, calls the appropriate Interactor which do some processing then pass the output through the Presenter instance.  Presenter: it converters the Output to the Model.  Model: this is the return data structure for MVC applications. And this is how looks a Controller for the Register Use Case. We must highlight that the Controller knows which Interactor to call but it does not care about the Output of it, instead the Controller delegates the responsibility of generating a Model to the Presenter instance. 1234567891011121314151617181920212223242526[Route( api/[controller] )]public class CustomersController : Microsoft. AspNetCore. Mvc. Controller{  private readonly IInputBoundary&lt;RegisterInput&gt; registerInput;  private readonly Presenter registerPresenter;  public CustomersController(    IInputBoundary&lt;RegisterInput&gt; registerInput,    Presenter registerPresenter)  {    this. registerInput = registerInput;    this. registerPresenter = registerPresenter;  }  /// &lt;summary&gt;  /// Register a new Customer  /// &lt;/summary&gt;  [HttpPost]  public async Task&lt;IActionResult&gt; Post([FromBody]RegisterRequest message)  {    var request = new RegisterInput(      message. PIN, message. Name, message. InitialAmount);    await registerInput. Process(request);    return registerPresenter. ViewModel;  }}An Presenter class is detailed bellow and it shows a conversion from the RegisterOutput to two different ViewModels. One ViewModel for null Outputs and another ViewModel for successful registrations. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class Presenter : IOutputBoundary&lt;RegisterOutput&gt;{  public IActionResult ViewModel { get; private set; }  public RegisterOutput Output { get; private set; }  public void Populate(RegisterOutput response)  {    Output = response;    if (response == null)    {      ViewModel = new NoContentResult();      return;    }        List&lt;TransactionModel&gt; transactions = new List&lt;TransactionModel&gt;();    foreach (var item in response. Account. Transactions)    {      var transaction = new TransactionModel(        item. Amount,        item. Description,        item. TransactionDate);      transactions. Add(transaction);    }    AccountDetailsModel account = new AccountDetailsModel(      response. Account. AccountId,      response. Account. CurrentBalance,      transactions);    List&lt;AccountDetailsModel&gt; accounts = new List&lt;AccountDetailsModel&gt;();    accounts. Add(account);    Model model = new Model(      response. Customer. CustomerId,      response. Customer. Personnummer,      response. Customer. Name,      accounts    );    ViewModel = new CreatedAtRouteResult( GetCustomer ,       new { customerId = model. CustomerId },       model);  }}4. Frameworks &amp; Drivers: Our more external layer is the Frameworks &amp; Drivers who implements Data Base Access, Dependency Injection Framework (DI), JSON Serializer and technology specific stuff. It has an CustomerRepository implementation. See the GitHub for the MongoContext and other Repositories classes. 123456789101112131415161718192021222324252627282930public class CustomerRepository : ICustomerReadOnlyRepository, ICustomerWriteOnlyRepository{  private readonly Context mongoContext;  public CustomerRepository(Context mongoContext)  {    this. mongoContext = mongoContext;  }  public async Task Get(Guid customerId)  {    Customer customer = await mongoContext. Customers      . Find(e =&gt; e. Id == customerId)      . SingleOrDefaultAsync();    return customer;  }  public async Task Add(Customer customer)  {    await mongoContext. Customers      . InsertOneAsync(customer);  }  public async Task Update(Customer customer)  {    await mongoContext. Customers      . ReplaceOneAsync(e =&gt; e. Id == customer. Id, customer);  }}We group the DI by Autofac Modules and created rules for selecting the interfaces and implementations by namespace patterns. 123456789101112131415161718192021public class InfrastructureModule : Autofac. Module{  public string ConnectionString { get; set; }  public string DatabaseName { get; set; }  protected override void Load(ContainerBuilder builder)  {    builder. RegisterType()      . As()      . WithParameter( connectionString , ConnectionString)      . WithParameter( databaseName , DatabaseName)      . SingleInstance();    //    // Register all Types in Manga. Infrastructure    //    builder. RegisterAssemblyTypes(typeof(OutputConverter). Assembly)      . AsImplementedInterfaces()      . InstancePerLifetimeScope();  }}And finally everything is tied together with configurations in the autofac. json which also makes possible to change implementations easily: 12345678910111213141516171819202122{  defaultAssembly :  Manga. Infrastructure ,  modules : [  {    type :  Manga. Infrastructure. Modules. WebApiModule ,    properties : {   }  },  {    type :  Manga. Infrastructure. Modules. ApplicationModule ,    properties : {   }  },  {    type :  Manga. Infrastructure. Modules. InfrastructureModule ,    properties : {     ConnectionString :  mongodb://10. 0. 75. 1:27017 ,     DatabaseName :  Manga-V01    }  } ]}Summing up, we separated the Solution in projects so we could draw boundaries between the modules, clarify the dependencies and we have small classes that makes easy to create new features without changing the existing ones. These are the Solution Explorer in Visual Studio 2017: And to help you understand the dependencies between the projects this diagram: Finally, as we did not cover every detail in source code take a look at. 123git clone https://github. com/ivanpaulovich/manga. gitcd manga/source/WebAPI/Manga. WebApidotnet runOr by: I hope that this template could improve your productivity in building applications with evolutionary architecture. Updates: I changed the installation and template generation command lines. "
    }, {
    "id": 23,
    "url": "/check-out-these-awesome-hexagonal-and-clean-architectures-implementations/",
    "title": "Check out these awesome Hexagonal and Clean Architectures implementations!",
    "body": "2018/04/05 - Filipe Augusto and I have been designing architectures and adapting legacy systems to more sophisticated market standards for a few years. Software Architecture is not a snapshot, it is a living thing and after several proofs of concept in real world systems, we come to some implementations that cover different scenarios. To illustrate, we published on GitHub three projects with architecture practices for highly testable, framework and database independent softwares. The first one is the Acerola Project, which follows the Hexagonal Architecture (in the center there’s a Domain plus the Application and externally Ports and Adapters). The second one is the Manga Project that goes beyond the Hexagonal Architecture and uses the rules of dependencies and patterns of Clean Architecture. It places User Cases as first-class objects and dependencies must point only inward, toward high-level policies. The last one is Amora Project, an Angular frontend for the previous microservices. Everything we’ve published is fresh new and we are in the alpha releases. We’re planning to implement and explore new concepts in the future, as Fitness Functions and show by example integrations between few microservices via Broker and Mediator pattern. These projects were born in the DevOps, Cloud and Container era, they come with CI/CD, TDD, Docker, . NET Core and Azure! Feedback and pull requests are welcome! Check out the projects. Worth it! "
    }, {
    "id": 24,
    "url": "/clean-architecture-essentials/",
    "title": "Clean Architecture Essentials",
    "body": "2018/01/20 - The “Software Architecture”We usually see Software Architecture descriptions like “The software architecture is an ASP. NET Web API with Entity Framework Core and SQL Server”. This article explains why you should describe software by the use cases instead of layers and the frameworks it uses. Secondly, I will distill the Clean Architecture Principles. Architecture is About Usage: By a quick look at the following blueprint, you can easily guess it is for a church, a theater or a place that people can gather together. Mostly because there is an open space with many benches focused on the same direction, big doors so a large number of people can enter and leave quickly.  It is not a house blueprint, right?  The challenge in software design is to scream the use cases in source code in a way that the first look tells us what the software does instead of frameworks that it is made of. The default approach of software development is to prioritize the frameworks and technology details. An e-commerce website will scream Web at you, Model-View-Controller or any other framework building blocks. Could we design the software in a different way? Let’s introduce Clean Architecture. Clean Architecture: The Clean Architecture style aims for a loosely coupled implementation focused on use cases and it is summarized as:  It is an architecture style that the Use Cases are the central organizing structure.  Follows the Ports and Adapters pattern.      The implementation is guided by tests (TDD Outside-In).    Decoupled from technology details.     Follows lots of principles (Stable Abstractions Principle, Stable Dependencies Principle, SOLID and so on). Use Cases: Use Cases are algorithms that interpret the input to generate the output data, their implementation should be closer as possible to the business vocabulary. When talking about a use case, it does not matter if it a Mobile or a Desktop application, use cases are delivery independent. The most important about use cases is how they interact with the actors.  Primary actors initiate a use case. They can be the End User, another system or a clock.  Secondary actors are affected by use cases. A set of use cases is used to describe software. Following the Customer primary actor on the left side, in the middle the Ticket Terminal system and the secondary actors on the right side: This article uses code snippets from sample applications and talks. If you are familiar with . NET, these GitHub projects host the full implementation:  Clean Architecture Manga.  Todo. Following the project structure: Following the Register Use Case implementation: 1234567891011121314151617181920public sealed class Register : IUseCase{  public async Task Execute(RegisterInput input)  {    var customer = _entityFactory. NewCustomer(input. SSN, input. Name);    var account = _entityFactory. NewAccount(customer);    var credit = account. Deposit(_entityFactory, input. InitialAmount);    customer. Register(account);    await _customerRepository. Add(customer);    await _accountRepository. Add(account, credit);    await _unitOfWork. Save();    var output = new RegisterOutput(customer, account);    _outputPort. Standard(output);  }  // properties and constructor ommited}The use cases are first-class objects in the application and WebApi layers. By a quick look at the use case names in the source tree, you can guess that the source code is for a Wallet software. In natural language the RegisterUseCase steps are:  Instantiate a Customer.  Open up an Account then Deposit an Initial Amount.  Save the data.  Write a message to the output port. Ports and Adapters a. k. a Hexagonal Architecture: Clean Architecture applies the Separation of Concerns Principle through the Ports and Adapters pattern. This means that the application layer exposes Ports (Interfaces) and Adapters are implemented in the infrastructure layer.  Ports can be an Input Port or an Output Port. The Input Port is called by the Primary Actors and the Output Ports are invoked by the Use Cases.  Adapters are technology-specific. This is the preferred architectural style for microservices. Unfortunately, I see lots of incomplete implementations and source code that do not get the most of the pattern. The previous picture shows for each dependency two implementations, one Fake (Test Double) implementation, and one Real Implementation. The purpose of it is to make possible to run the software independently of external dependencies.  A Fake implementation provides an illusion of external dependencies, it has the same capabilities expected from the real implementation and it runs without I/O. The issue that I see in many codebases is the focus on implementing tests against Mocks which can only run through Unit Tests. A fake could run in the Production environment, can help the developer get feedback and it really pays back the investment. Let’s start with the Hexagonal Architecture style intent:  Develop, test and run an application in isolation of external devices. Allows a developer to get feedback after every new implementation. Follow TDD Outside-in in order to achieve the intent:  Start the development from the Test Cases, implement the Use Cases.  When you find a dependency, instead of implementing the real one start by creating a Fake (Test Double).  Get Feedback, make possible to run your application against the Fakes. You can even publish it to production.  Implement the real adapter in isolation.  The last step is to create the User Interface. Principles: Clean Architecture is full of principles, let’s analyze code snippets for the different levels of Stability and Abstraction: The IAccountRepository interface is highly abstract, general and stable. It does not have “implementation”, it is a high-level concept and it does not have dependencies. 12345678public interface IAccountRepository{  Task&lt;IAccount&gt; Get(Guid id);  Task Add(IAccount account, ICredit credit);  Task Update(IAccount account, ICredit credit);  Task Update(IAccount account, IDebit debit);  Task Delete(IAccount account);}The AccountRepository is a Very Concrete sealed class, and it isVery Specific to Entity Framework and Unstable by implementing interfaces and depending on libraries. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public sealed class AccountRepository : IAccountRepository{  private readonly MangaContext _context;  public AccountRepository(MangaContext context)  {    _context = context ??      throw new ArgumentNullException(nameof(context));  }  public async Task Add(IAccount account, ICredit credit)  {    await _context. Accounts. AddAsync((EntityFrameworkDataAccess. Account) account);    await _context. Credits. AddAsync((EntityFrameworkDataAccess. Credit) credit);  }  public async Task Delete(IAccount account)  {    string deleteSQL =      @ DELETE FROM Credit WHERE AccountId = @Id;          DELETE FROM Debit WHERE AccountId = @Id;          DELETE FROM Account WHERE Id = @Id; ;    var id = new SqlParameter( @Id , account. Id);    int affectedRows = await _context. Database. ExecuteSqlRawAsync(      deleteSQL, id);  }  public async Task&lt;IAccount&gt; Get(Guid id)  {    Infrastructure. EntityFrameworkDataAccess. Account account = await _context      . Accounts      . Where(a =&gt; a. Id == id)      . SingleOrDefaultAsync();    if (account is null)      throw new AccountNotFoundException($ The account {id} does not exist or is not processed yet.  );    var credits = _context. Credits      . Where(e =&gt; e. AccountId == id)      . ToList();    var debits = _context. Debits      . Where(e =&gt; e. AccountId == id)      . ToList();    account. Load(credits, debits);    return account;  }  public async Task Update(IAccount account, ICredit credit)  {    await _context. Credits. AddAsync((EntityFrameworkDataAccess. Credit) credit);  }  public async Task Update(IAccount account, IDebit debit)  {    await _context. Debits. AddAsync((EntityFrameworkDataAccess. Debit) debit);  }}The RegisterRequest class is concrete, by exposing getters and setters it is inconsistent and specific to the consumer. 1234567891011121314151617181920212223/// &lt;summary&gt;/// Registration Request/// &lt;/summary&gt;public sealed class RegisterRequest{  /// &lt;summary&gt;  /// SSN  /// &lt;/summary&gt;  [Required]  public string SSN { get; set; }  /// &lt;summary&gt;  /// Name  /// &lt;/summary&gt;  [Required]  public string Name { get; set; }  /// &lt;summary&gt;  /// Initial Amount  /// &lt;/summary&gt;  [Required]  public decimal InitialAmount { get; set; }}The RegisterInput class is concrete, a little bit consistent and less specific. 12345678910111213141516public sealed class RegisterInput : IUseCaseInput{  public SSN SSN { get; }  public Name Name { get; }  public PositiveMoney InitialAmount { get; }  public RegisterInput(    SSN ssn,    Name name,    PositiveMoney initialAmount)  {    SSN = ssn;    Name = name;    InitialAmount = initialAmount;  }}The last one is the IAccount interface that is highly abstract, general and stable. 1234567public interface IAccount : IAggregateRoot{  ICredit Deposit(IEntityFactory entityFactory, PositiveMoney amountToDeposit);  IDebit Withdraw(IEntityFactory entityFactory, PositiveMoney amountToWithdraw);  bool IsClosingAllowed();  Money GetCurrentBalance();}The Clean Architecture Principles will guide you to place objects with certain properties according to the following spectrum: Another Clean Architecture representation is by concentric circles, where:  The more inner in the diagram the more the layer is stable and abstract.  The dependency direction goes inwards the center.  Classes that change together are packaged together. Following another complete example showing that:  The User Interface and the Infrastructure Layers are very unstable and concrete. Highly specific to the devices they are designed for.  The Core Layer is highly abstract and general. Very stable. Plugin Architecture: During the software development, we will inevitably face discussions about what is the best frontend framework, best database or ORM. We should no fall into these never-ending discussions and deffer decisions like those in the earlier stages. Consider the Uncle Bob quote:  A good architecture allows major decisions to be deferred.  A good architect maximizes the number of decisions not made. One can easily find arguments to say that NoSQL is the best database, another developer can find good arguments to choose SQL Server as the database. My answer to this is that either one should be implemented. The best option is to implement the Fake storage and move on with the project.  Keep in mind that you should embrace the change because in the future you will find a Cloud service that will be the better option. Ports and Adapters in details: Pluggable User Interface Decoupling the User Interface is equally important than decoupling Repositories and Services but we usually don’t put much effort into it. This practice leads to Controllers that look like God classes, hard to test and to maintain. Suppose that you have a GetAccountDetailsUseCase. It should display one of the following options:  The Account Details.  Not Found in case it does not exits. The initial code should look like: 12345678910111213public async Task&lt;IActionResult&gt; Get([FromRoute][Required] GetAccountDetailsRequest request){  var input = new GetAccountDetailsInput(request. AccountId);  try  {    var output = await _useCase. Execute(input);    return Ok(output);  }  catch (AccountNotFoundException ex)  {    return NotFound(ex. Message);  }}I wish that the Controller does not know about the output message to decide which View to return. Let’s delegate these responsibility to the Presenter.  Both Controller and UseCase implementations uses the same Presenter instance. The Controller does not know about the output message, so we can have an Action that looks like: 123456789101112/// &lt;summary&gt;/// Get an account details/// &lt;/summary&gt;[HttpGet( {AccountId} , Name =  GetAccount )][ProducesResponseType(StatusCodes. Status200OK, Type = typeof(GetAccountDetailsResponse))][ProducesResponseType(StatusCodes. Status404NotFound)]public async Task&lt;IActionResult&gt; Get([FromRoute][Required] GetAccountDetailsRequest request){  var input = new GetAccountDetailsInput(request. AccountId);  await _useCase. Execute(input);  return _presenter. ViewModel;}The Presenter is in charge of translating the Value Objects into a WebApi response. Fortunately the Value Objects exposes a ToDecimal() or ToString() methods which converts it into primitive types. The GetAccountDetailsPresenter implements both NotFound and Standard methods mimicking the StdOut and StdErr from Unix. These methods creates the ViewModel object. 12345678910111213141516171819202122232425262728293031323334353637public interface IOutputPort{  void NotFound(string message);  void Standard(GetAccountDetailsOutput getAccountDetailsOutput);}public sealed class GetAccountDetailsPresenter : IOutputPort{  public IActionResult ViewModel { get; private set; }  public void NotFound(string message)  {    ViewModel = new NotFoundObjectResult(message);  }  public void Standard(GetAccountDetailsOutput output)  {    var transactions = new List&lt;TransactionModel&gt;();    foreach (var item in output. Transactions)    {      var transaction = new TransactionModel(        item. Amount. ToMoney(). ToDecimal(),        item. Description,        item. TransactionDate);      transactions. Add(transaction);    }    var response = new GetAccountDetailsResponse(      output. AccountId,      output. CurrentBalance. ToDecimal(),      transactions);    ViewModel = new OkObjectResult(response);  }}The GetAccountDetailsUseCase depends on the IOutputPort interface and it calls NotFound or Standard method accordingly. 12345678910111213141516171819202122232425262728293031public sealed class GetAccountDetails : IUseCase, IUseCaseV2{  private readonly IOutputPort _outputPort;  private readonly IAccountRepository _accountRepository;  public GetAccountDetails(    IOutputPort outputPort,    IAccountRepository accountRepository)  {    _outputPort = outputPort;    _accountRepository = accountRepository;  }  public async Task Execute(GetAccountDetailsInput input)  {    IAccount account;    try    {      account = await _accountRepository. Get(input. AccountId);    }    catch (AccountNotFoundException ex)    {      _outputPort. NotFound(ex. Message);      return;    }    var output = new GetAccountDetailsOutput(account);    _outputPort. Standard(output);  }}Adding a Mediator: 123456789101112/// &lt;summary&gt;/// Get an account details/// &lt;/summary&gt;[HttpGet( {AccountId} , Name =  GetAccount )][ProducesResponseType(StatusCodes. Status200OK, Type = typeof(GetAccountDetailsResponse))][ProducesResponseType(StatusCodes. Status404NotFound)]public async Task&lt;IActionResult&gt; Get([FromRoute][Required] GetAccountDetailsRequest request){  var input = new GetAccountDetailsInput(request. AccountId);  await _mediator. PublishAsync(input);  return _presenter. ViewModel;}You notice that I added the mediator instance to decouple the Controller and the UseCase, it means that the Controller will produce messages, give them to the mediator then the mediator will deliver the message to the appropriate UseCase. Of course, you can invoke the UseCase directly, verify whats works best for your project. By definition the Output messages given by the UseCase are a consistent and immutable objects, it uses Value Objects to describe the business state. Evolutionary ArchitectureAll developers will build a Task List app at least once. As a . NET Developer we always start thinking by creating an WebApi first then dig into the business details, for this sample application I wanted to proceed differently.  I started the development from the Unit Tests, implementing the Use Cases independently and for each dependency creating a Fake. After a while I decided to create a SQL Server database because that is what . NET Developers do, we spin up a SQL Server so we can persist taks ;) To make it short, at the end a Console UI and a Storage to GitHub gist was good enough for me.  Wrapping Up Clean Architecture is about usage and the use cases are the central organizing principle.  Use cases implementation are guided by tests.  The User Interface and Persistence are designed to fulfill the core needs (not the opposite!).  Defer decisions by implementing the simplest component first. The source code is on GitHub and it is updated frequently with new videos and pull-requests. Check it out! "
    }];

var idx = lunr(function () {
    this.ref('id')
    this.field('title')
    this.field('body')

    documents.forEach(function (doc) {
        this.add(doc)
    }, this)
});
function lunr_search(term) {
    document.getElementById('lunrsearchresults').innerHTML = '<ul></ul>';
    if(term) {
        document.getElementById('lunrsearchresults').innerHTML = "<p>Search results for '" + term + "'</p>" + document.getElementById('lunrsearchresults').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>No results found...</li>";
        }
    }
    return false;
}

function lunr_search(term) {
    $('#lunrsearchresults').show( 400 );
    $( "body" ).addClass( "modal-open" );
    
    document.getElementById('lunrsearchresults').innerHTML = '<div id="resultsmodal" class="modal fade show d-block"  tabindex="-1" role="dialog" aria-labelledby="resultsmodal"> <div class="modal-dialog shadow-lg" role="document"> <div class="modal-content"> <div class="modal-header" id="modtit"> <button type="button" class="close" id="btnx" data-dismiss="modal" aria-label="Close"> &times; </button> </div> <div class="modal-body"> <ul class="mb-0"> </ul>    </div> <div class="modal-footer"><button id="btnx" type="button" class="btn btn-danger btn-sm" data-dismiss="modal">Close</button></div></div> </div></div>';
    if(term) {
        document.getElementById('modtit').innerHTML = "<h5 class='modal-title'>Search results for '" + term + "'</h5>" + document.getElementById('modtit').innerHTML;
        //put results on the screen.
        var results = idx.search(term);
        if(results.length>0){
            //console.log(idx.search(term));
            //if results
            for (var i = 0; i < results.length; i++) {
                // more statements
                var ref = results[i]['ref'];
                var url = documents[ref]['url'];
                var title = documents[ref]['title'];
                var body = documents[ref]['body'].substring(0,160)+'...';
                document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML + "<li class='lunrsearchresult'><a href='" + url + "'><span class='title'>" + title + "</span><br /><small><span class='body'>"+ body +"</span><br /><span class='url'>"+ url +"</span></small></a></li>";
            }
        } else {
            document.querySelectorAll('#lunrsearchresults ul')[0].innerHTML = "<li class='lunrsearchresult'>Sorry, no results found. Close & try a different search!</li>";
        }
    }
    return false;
}
    
$(function() {
    $("#lunrsearchresults").on('click', '#btnx', function () {
        $('#lunrsearchresults').hide( 5 );
        $( "body" ).removeClass( "modal-open" );
    });
});